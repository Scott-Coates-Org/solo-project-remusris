{"ast":null,"code":"export default function (d) {\n  if (isNaN(x = +this._x.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      x1 = this._x1,\n      x,\n      xm,\n      right,\n      i,\n      j; // If the tree is empty, initialize the root as a leaf.\n\n  if (!node) return this; // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;\n    if (!(parent = node, node = node[i = +right])) return this;\n    if (!node.length) break;\n    if (parent[i + 1 & 1]) retainer = parent, j = i;\n  } // Find the point to remove.\n\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n\n  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.\n\n  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.\n\n  if (!parent) return this._root = next, this; // Remove this leaf.\n\n  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.\n\n  if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) {\n    if (retainer) retainer[j] = node;else this._root = node;\n  }\n\n  return this;\n}\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n\n  return this;\n}","map":{"version":3,"names":["d","isNaN","x","_x","call","parent","node","_root","retainer","previous","next","x0","_x0","x1","_x1","xm","right","i","j","length","data","removeAll","n","remove"],"sources":["C:/Users/bugat/Documents/Personal Coding Projects/React-Force-Graph-Test/node_modules/d3-binarytree/src/remove.js"],"sourcesContent":["export default function(d) {\r\n  if (isNaN(x = +this._x.call(null, d))) return this; // ignore invalid points\r\n\r\n  var parent,\r\n      node = this._root,\r\n      retainer,\r\n      previous,\r\n      next,\r\n      x0 = this._x0,\r\n      x1 = this._x1,\r\n      x,\r\n      xm,\r\n      right,\r\n      i,\r\n      j;\r\n\r\n  // If the tree is empty, initialize the root as a leaf.\r\n  if (!node) return this;\r\n\r\n  // Find the leaf node for the point.\r\n  // While descending, also retain the deepest parent with a non-removed sibling.\r\n  if (node.length) while (true) {\r\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\r\n    if (!(parent = node, node = node[i = +right])) return this;\r\n    if (!node.length) break;\r\n    if (parent[(i + 1) & 1]) retainer = parent, j = i;\r\n  }\r\n\r\n  // Find the point to remove.\r\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\r\n  if (next = node.next) delete node.next;\r\n\r\n  // If there are multiple coincident points, remove just the point.\r\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\r\n\r\n  // If this is the root point, remove it.\r\n  if (!parent) return this._root = next, this;\r\n\r\n  // Remove this leaf.\r\n  next ? parent[i] = next : delete parent[i];\r\n\r\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\r\n  if ((node = parent[0] || parent[1])\r\n      && node === (parent[1] || parent[0])\r\n      && !node.length) {\r\n    if (retainer) retainer[j] = node;\r\n    else this._root = node;\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\nexport function removeAll(data) {\r\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\r\n  return this;\r\n}\r\n"],"mappings":"AAAA,eAAe,UAASA,CAAT,EAAY;EACzB,IAAIC,KAAK,CAACC,CAAC,GAAG,CAAC,KAAKC,EAAL,CAAQC,IAAR,CAAa,IAAb,EAAmBJ,CAAnB,CAAN,CAAT,EAAuC,OAAO,IAAP,CADd,CAC2B;;EAEpD,IAAIK,MAAJ;EAAA,IACIC,IAAI,GAAG,KAAKC,KADhB;EAAA,IAEIC,QAFJ;EAAA,IAGIC,QAHJ;EAAA,IAIIC,IAJJ;EAAA,IAKIC,EAAE,GAAG,KAAKC,GALd;EAAA,IAMIC,EAAE,GAAG,KAAKC,GANd;EAAA,IAOIZ,CAPJ;EAAA,IAQIa,EARJ;EAAA,IASIC,KATJ;EAAA,IAUIC,CAVJ;EAAA,IAWIC,CAXJ,CAHyB,CAgBzB;;EACA,IAAI,CAACZ,IAAL,EAAW,OAAO,IAAP,CAjBc,CAmBzB;EACA;;EACA,IAAIA,IAAI,CAACa,MAAT,EAAiB,OAAO,IAAP,EAAa;IAC5B,IAAIH,KAAK,GAAGd,CAAC,KAAKa,EAAE,GAAG,CAACJ,EAAE,GAAGE,EAAN,IAAY,CAAtB,CAAb,EAAuCF,EAAE,GAAGI,EAAL,CAAvC,KAAqDF,EAAE,GAAGE,EAAL;IACrD,IAAI,EAAEV,MAAM,GAAGC,IAAT,EAAeA,IAAI,GAAGA,IAAI,CAACW,CAAC,GAAG,CAACD,KAAN,CAA5B,CAAJ,EAA+C,OAAO,IAAP;IAC/C,IAAI,CAACV,IAAI,CAACa,MAAV,EAAkB;IAClB,IAAId,MAAM,CAAEY,CAAC,GAAG,CAAL,GAAU,CAAX,CAAV,EAAyBT,QAAQ,GAAGH,MAAX,EAAmBa,CAAC,GAAGD,CAAvB;EAC1B,CA1BwB,CA4BzB;;EACA,OAAOX,IAAI,CAACc,IAAL,KAAcpB,CAArB,EAAwB,IAAI,EAAES,QAAQ,GAAGH,IAAX,EAAiBA,IAAI,GAAGA,IAAI,CAACI,IAA/B,CAAJ,EAA0C,OAAO,IAAP;;EAClE,IAAIA,IAAI,GAAGJ,IAAI,CAACI,IAAhB,EAAsB,OAAOJ,IAAI,CAACI,IAAZ,CA9BG,CAgCzB;;EACA,IAAID,QAAJ,EAAc,OAAQC,IAAI,GAAGD,QAAQ,CAACC,IAAT,GAAgBA,IAAnB,GAA0B,OAAOD,QAAQ,CAACC,IAA/C,EAAsD,IAA7D,CAjCW,CAmCzB;;EACA,IAAI,CAACL,MAAL,EAAa,OAAO,KAAKE,KAAL,GAAaG,IAAb,EAAmB,IAA1B,CApCY,CAsCzB;;EACAA,IAAI,GAAGL,MAAM,CAACY,CAAD,CAAN,GAAYP,IAAf,GAAsB,OAAOL,MAAM,CAACY,CAAD,CAAvC,CAvCyB,CAyCzB;;EACA,IAAI,CAACX,IAAI,GAAGD,MAAM,CAAC,CAAD,CAAN,IAAaA,MAAM,CAAC,CAAD,CAA3B,KACGC,IAAI,MAAMD,MAAM,CAAC,CAAD,CAAN,IAAaA,MAAM,CAAC,CAAD,CAAzB,CADP,IAEG,CAACC,IAAI,CAACa,MAFb,EAEqB;IACnB,IAAIX,QAAJ,EAAcA,QAAQ,CAACU,CAAD,CAAR,GAAcZ,IAAd,CAAd,KACK,KAAKC,KAAL,GAAaD,IAAb;EACN;;EAED,OAAO,IAAP;AACD;AAED,OAAO,SAASe,SAAT,CAAmBD,IAAnB,EAAyB;EAC9B,KAAK,IAAIH,CAAC,GAAG,CAAR,EAAWK,CAAC,GAAGF,IAAI,CAACD,MAAzB,EAAiCF,CAAC,GAAGK,CAArC,EAAwC,EAAEL,CAA1C,EAA6C,KAAKM,MAAL,CAAYH,IAAI,CAACH,CAAD,CAAhB;;EAC7C,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}